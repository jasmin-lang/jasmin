open Utils
open Prog
open Constraints

module S = Syntax
module Pt = Pretyping

(* ----------------------------------------------------------- *)
let pp_var fmt x = Printer.pp_var ~debug:false fmt x

let pp_var_i fmt x = pp_var fmt (L.unloc x)

let pp_expr fmt e = Printer.pp_expr ~debug:false fmt e

let pp_lval fmt x = Printer.pp_lval ~debug:false fmt x

let pp_vset fmt xs =
  Format.fprintf fmt "{@[ %a @]}"  (pp_list ",@ " pp_var) (Sv.elements xs)


(* ----------------------------------------------------------- *)
let ssecret = "secret"
let spoly   = "poly"
let spublic = "public"
let stransient = "transient"
let smsf = "msf"

let sflexible = "flex"
let sstrict   = "strict"


(* ----------------------------------------------------------- *)
(* Info provided by the user                                   *)
type ulevel =
  | Poly of string L.located
  | Secret
  | Transient
  | Public
  | Msf

type uconstraints = (ulevel * ulevel) list
type unomodmsf = bool option


(* -------------------------------------------------------------- *)
(* Special operators to deal with msf                             *)
type special_op =
  | Init_msf
  | Set_msf
  | Mov_msf
  | Protect
  | Other

let is_special = function
  | Sopn.Oprotect _ -> Protect
  | Oprotect_ptr _  -> Protect
  | Oset_msf        -> Set_msf
  | Oinit_msf       -> Init_msf
  | Omov_msf        -> Mov_msf
  | _ -> Other


(* -----------------------------------------------------------*)
(* Types generated by the system                              *)

(* Attempt of convention: n stands for normal (non-speculative),
   s for speculative *)

type vty =
  | Direct of VlPairs.t
  | Indirect of VlPairs.t * VlPairs.t

let pp_vty fmt = function
  | Direct (n, s) -> Format.fprintf fmt "(n: %a, s: %a)" Lvl.pp n Lvl.pp s
  | Indirect ((n1, s1), (n2, s2))  ->
      Format.fprintf fmt "Address: (n: %a, s: %a); Value: (n: %a, s: %a)"
        Lvl.pp n1 Lvl.pp s1 Lvl.pp n2 Lvl.pp s2

type vfty =
  | IsMsf
  | IsNormal of vty

let pp_vfty fmt = function
  | IsMsf -> Format.fprintf fmt "%s" smsf
  | IsNormal ty -> pp_vty fmt ty

type ty_fun = {
    modmsf               : bool;
    tyin                 : vfty list;
    tyout                : vfty list;
    constraints          : C.constraints;
    input_corruption     : VlPairs.t; (* input memory corruption before function call *)
    resulting_corruption : VlPairs.t (* resulting memory corruption after function call *)
  }

type 'info fenv = {
    env_ty     : ty_fun Hf.t;
    env_def    : 'info func list;
  }

module FEnv = struct
  let get_fun_def fenv fn = List.find (fun f -> F.equal f.f_name fn) fenv.env_def

  let get_fty fenv fn =
    try Hf.find fenv.env_ty fn with Not_found -> assert false

end

let pp_modmsf fmt modmsf =
  Format.fprintf fmt "%s" (if modmsf then "modmsf" else "nomodmsf")

let pp_funty fmt (fname, tyfun) =
  Format.fprintf fmt
    "@[<v>%a %s : @[%a@] -> @[%a@]@ \
      input corruption: %a@.\
      output corruption: %a@.\
      @ constraints: @[%a@]@]@."
    pp_modmsf tyfun.modmsf
    fname
    (pp_list " *@ " pp_vfty) tyfun.tyin
    (pp_list " *@ " pp_vfty) tyfun.tyout
    pp_vty (Direct (tyfun.input_corruption))
    pp_vty (Direct (tyfun.resulting_corruption))
    C.pp tyfun.constraints


(* --------------------------------------------------------------- *)
(* Checks if the status of msf is modified by the instructions     *)

let is_inline i =
  match Pt.Annot.ensure_uniq1 "inline" Pt.Annot.none i.i_annot with
  | Some _ -> true
  | None   -> false

let rec modmsf_i fenv i =
  match i.i_desc with
  | Csyscall _ | Cwhile _ -> true
  | Cif _ -> not (is_inline i)
  | Cassgn _ -> false
  | Copn (_, _, o, _) ->
    begin match is_special o with
    | Init_msf -> true (* Lfence modify msf *)
    | Set_msf  -> true (* not sure it is needed *)
    | Mov_msf | Protect | Other -> false
    end
  | Cfor(_, _, c) -> modmsf_c fenv c
  | Ccall (_, _, f, _) -> (FEnv.get_fty fenv f).modmsf

and modmsf_c fenv c =
  List.exists (modmsf_i fenv) c


(* --------------------------------------------------------- *)
(* Inference of the variables that need to contain msf       *)
(* This code does not need to be trusted it is simply        *)
(* used as an oracle                                         *)

let is_register ~direct x =
  is_reg_kind x.v_kind && (* direct => is_reg_direct_kind *)
    (not direct || is_reg_direct_kind x.v_kind)

let ensure_register ~direct x =
  if not (is_register ~direct (L.unloc x)) then
    Pt.rs_tyerror ~loc:(L.loc x)
      (Pt.string_error "variable %a must be a reg%s" pp_var_i x
         (if direct then "" else " (ptr)"))

let reg_lval ~direct loc x =
  match x with
  | Lvar x -> ensure_register ~direct x; x
  | _ ->
    Pt.rs_tyerror ~loc (Pt.string_error "%a must be a reg%s" pp_lval x
                          (if direct then "" else " (ptr)"))

let reg_expr ~direct loc e =
  match e with
  | Pvar x when is_gkvar x -> ensure_register ~direct x.gv; x.gv
  | _ -> Pt.rs_tyerror ~loc (Pt.string_error "%a must be a reg%s" pp_expr e
                               (if direct then "" else " (ptr)"))


let rec infer_msf_i fenv (tbl:(L.i_loc, Sv.t) Hashtbl.t) i ms =
  let loc = i.i_loc.L.base_loc in

  let check_x ms x =
    if Sv.mem (L.unloc x) ms then
      Pt.rs_tyerror ~loc:(L.loc x)
        (Pt.string_error ("instruction assigns %a, which is required to be a msf")
           pp_var_i x) in

  let check ms x =
    match x with
    | Lvar x -> check_x ms x
    | _ -> () in

  let checks ms xs = List.iter (check ms) xs in

  match i.i_desc with
  | Csyscall _ ->
      if not (Sv.is_empty ms) then
       Pt.rs_tyerror ~loc
         (Pt.string_error ("syscalls destroy msf variables, %a are required") pp_vset ms);
      Sv.empty

  | Cif (_, c1, c2) ->
    let ms1 = infer_msf_c fenv tbl c1 ms in
    let ms2 = infer_msf_c fenv tbl c2 ms in
    Sv.union ms1 ms2

  | Cfor(x, _, c) ->
    check_x ms x;
    let rec loop ms =
      let ms' = infer_msf_c fenv tbl c ms in
      if Sv.subset ms' ms then (Hashtbl.add tbl i.i_loc ms'; ms')
      else loop (Sv.union ms' ms) in
    loop ms

  | Cwhile (_, c1, _, c2) ->
    (* c1; while e do c2; c1 *)
    let rec loop ms =
      let ms1 = infer_msf_c fenv tbl c1 ms in
      let ms2 = infer_msf_c fenv tbl c2 ms1 in
      if Sv.subset ms2 ms then (Hashtbl.add tbl i.i_loc ms1; ms1)
      else loop (Sv.union ms2 ms) in
    loop ms

  | Cassgn _ ->
    ms

  | Ccall(_, xs, f, es) ->
    let fty = FEnv.get_fty fenv f in
    let mso =
      if fty.modmsf then
        begin
          let doout ms vfty x =
            match vfty with
            | IsMsf -> let x = reg_lval ~direct:true loc x in Sv.add (L.unloc x) ms
            | _ -> ms in
          let mso = List.fold_left2 doout Sv.empty fty.tyout xs in
          if not (Sv.subset ms mso) then
            Pt.rs_tyerror ~loc
              (Pt.string_error ("calls destroy msf variables, %a are required")
                 pp_vset (Sv.diff ms mso));
          Sv.empty
        end
      else ms in
    let doin ms vfty e =
      match vfty with
      | IsMsf -> let x = reg_expr ~direct:true loc e in Sv.add (L.unloc x) ms
      | _ -> ms in
    List.fold_left2 doin mso fty.tyin es

  | Copn (xs, _, o, es) ->
    match is_special o, xs, es with
    | Init_msf, [x], _ ->
      let x = reg_lval ~direct:true loc x in
      if not (Sv.subset ms (Sv.singleton (L.unloc x))) then
        Pt.rs_tyerror ~loc
          (Pt.string_error ("only %a is ensured to be msf after init_msf, %a are required")
             pp_var_i x pp_vset ms);
      Sv.empty

    | Init_msf, _, _ -> assert false

    | Set_msf, [xms], [_e; ms'] ->
      let xms = reg_lval ~direct:true loc xms and ms' = reg_expr ~direct:true loc ms' in
      if not (Sv.subset ms (Sv.singleton (L.unloc xms))) then
        Pt.rs_tyerror ~loc
          (Pt.string_error ("only %a is ensured to be msf after set_msf, %a are required")
             pp_var_i xms pp_vset ms);
      Sv.singleton (L.unloc ms')

    | Set_msf, _, _ -> assert false

    | Mov_msf, [x], [x'] ->
      let x = reg_lval ~direct:true loc x and x' = reg_expr ~direct:true loc x' in
      Sv.add (L.unloc x') (Sv.remove (L.unloc x) ms)

    | Mov_msf, _, _ -> assert false

    | Protect, xs, [_; ms'] ->
      checks ms xs;
      let ms' = reg_expr ~direct:true loc ms' in
      Sv.add (L.unloc ms') ms

    | Protect, _, _ -> assert false

    | Other, xs, _ -> checks ms xs; ms

and infer_msf_c fenv tbl c ms =
  List.fold_right (infer_msf_i fenv tbl) c ms


(* --------------------------------------------------------- *)
(* Typing environment                                        *)

type var_kind = Strict | Flexible

module Env : sig
  type env  (* constraints holder *)
  type venv (* type variables association *)

  val init : unit -> env
  val empty : env -> venv
  val constraints : env -> C.constraints
  val add_var : env -> venv -> var -> var_kind -> vty -> venv

  val public    : env -> Lvl.t
  val secret    : env -> Lvl.t

  val public2    : env -> VlPairs.t
  val secret2    : env -> VlPairs.t

  val dpublic    : env -> vty
  val dsecret    : env -> vty

  val get   : venv -> var -> vty
  val get_i : venv -> var_i -> vty
  val gget  : venv -> int ggvar -> vty

  val fresh  : ?name:string -> env -> Lvl.t
  val fresh2 : ?name:string -> env -> VlPairs.t

  val init_ty : env -> venv -> var -> vty -> venv
  val set_ty : env -> venv -> var_i -> vty -> venv
  val set_init_msf : env -> venv -> var_i -> venv

  val max : env -> venv -> venv -> venv

  val get_msf_oracle : env -> (L.i_loc, Sv.t) Hashtbl.t
  val msf_oracle : env -> L.i_loc -> Sv.t

  val freshen : ?min:Constraints.VlPairs.t -> env -> venv -> venv
  val ensure_le : L.t -> venv -> venv -> unit
  val clone_for_call : env -> ty_fun -> vfty list * vfty list * VlPairs.t * VlPairs.t
          (* output type, input type, input corruption, output corruption *)

  val corruption : env -> venv -> VlPairs.t -> venv
  val corruption_speculative : env -> venv -> VlPairs.t -> venv

  val get_resulting_corruption : venv -> VlPairs.t
  val get_input_corruption : venv -> VlPairs.t

end = struct

  type env = {
      constraints : C.constraints;
      strictness  : unit Hv.t;
      msf_oracle  : (L.i_loc, Sv.t) Hashtbl.t;
    }

  type venv = {
      vtype : vty Mv.t;
      vars : Sv.t;
      input_corruption : VlPairs.t; (* only used for global variables, as they
      are the only ones that have been potentially affected by caller function *)
      (* TODO if global variables can successfully be compiled in .text, then no
         execution can alter them, which makes input_corruption redundant and removable *)
      resulting_corruption : VlPairs.t;
    }

  let init () =
    { constraints = C.init ();
      strictness = Hv.create 97;
      msf_oracle = Hashtbl.create 97; }

  let constraints env = env.constraints

  let public    env = C.public    env.constraints
  let transient env = C.transient env.constraints
  let secret    env = C.secret    env.constraints

  let public2   env = (public env, public env)
  let secret2   env = (secret env, secret env)

  let dpublic   env = Direct (public2 env)
  let dsecret   env = Direct (secret2 env)

  let fresh ?name env = C.fresh ?name env.constraints

  let fresh2 ?name env = (C.fresh ?name env.constraints,
                          C.fresh ?name env.constraints)

  let empty env = {
      vtype = Mv.empty;
      vars = Sv.empty;
      resulting_corruption = fresh2 env;
      input_corruption = fresh2 env;
    }

  let get venv x =
    try match x.v_kind with
    | Global -> Direct venv.input_corruption
    | _ -> Mv.find x venv.vtype
    with Not_found -> assert false

  let get_i venv x = get venv (L.unloc x)
  let gget venv x = get_i venv x.gv

  let kind env x = if Hv.mem env.strictness (L.unloc x)
    then Strict else Flexible

  let add_le_var ty1 ty2 =
    match ty1, ty2 with
    | Direct ty1, Direct ty2 -> VlPairs.add_le ty1 ty2
    | Indirect (l1, x1), Indirect (l2, x2) -> VlPairs.add_le l1 l2; VlPairs.add_le x1 x2
    | _ -> assert false

  let init_ty env venv x xty =
      (* TODO debug command *)
      (* warning Always (L.i_loc0 x.v_dloc) "initialisaing variable %a" pp_var x; *)
    let nxty =
      let public2 = public2 env in
      match x.v_kind, xty with
      | Const, Direct le -> VlPairs.add_le le public2; xty
      | Inline, Direct le -> VlPairs.add_le le public2; xty
      (* likely unused as global definitions are not part of functions and thus
         not parsed by the parser below *)
      | Global, Direct le  -> VlPairs.add_le venv.input_corruption le; xty

      | Stack Direct, Direct _ 
      | Stack (Pointer _), Indirect _
      | Reg (_, Direct), Direct _
      | Reg (_, Pointer _), Indirect _ -> xty

      | _, _ -> assert false
    in
    { venv with 
        vtype = Mv.add x nxty venv.vtype;
        vars = Sv.add x venv.vars
    }

  let add_var env venv x vk vty =
    assert (not (Hv.mem env.strictness x || Mv.mem x venv.vtype));
    if vk = Strict then Hv.add env.strictness x ();
    try init_ty env venv x vty
    with Lvl.Unsat _unsat ->
      Pt.rs_tyerror ~loc:(x.v_dloc)
        (Pt.string_error
           "invalid security annotations for %a, this leads to invalid constraints"
           pp_var x)

  let set_ty env venv x nxty =
    let xty = get_i venv x in
    try
      if kind env x = Flexible then
        init_ty env venv (L.unloc x) nxty
      else begin
        add_le_var xty nxty; venv
      end
    with Lvl.Unsat _unsat ->
      Pt.rs_tyerror ~loc:(L.loc x)
        (Pt.string_error
           "%a has strict type %a, it cannot receive a value of type %a"
           pp_var_i x pp_vty xty pp_vty nxty)

  (* Initialises type for InitMsf operations. Acts as a Fence operator *)
  let set_init_msf env venv ms =
    let venv = set_ty env venv ms (dpublic env) in
    let operate_fence _ = function
        | Direct le -> Direct (VlPairs.normalise le)
        | Indirect(lp, le) -> Indirect(VlPairs.normalise lp, VlPairs.normalise le)
    in
    { venv with vtype = Mv.mapi operate_fence venv.vtype }


  let max env venv1 venv2 =
    let merge1 l1 l2 =
      if Lvl.equal l1 l2 then l1
      else
        let l = fresh env in
        Lvl.add_le l1 l; Lvl.add_le l2 l;
        l in

    let merge (n1, s1) (n2, s2) =
      (merge1 n1 n2, merge1 s1 s2) in

    let merge_var _ oty1 oty2 =
      match oget oty1, oget oty2 with
      | Direct le1, Direct le2 -> Some (Direct (merge le1 le2))
      | Indirect(lp1, le1), Indirect(lp2, le2) -> Some (Indirect (merge lp1 lp2, merge le1 le2))
      | _ -> assert false
    in
    { venv1 with
      vtype = Mv.merge merge_var venv1.vtype venv2.vtype;
      resulting_corruption = merge venv1.resulting_corruption venv2.resulting_corruption
    }

  let get_msf_oracle env = env.msf_oracle

  let msf_oracle env loc =
    try Hashtbl.find env.msf_oracle loc with Not_found -> assert false

  (* freshen all variables in environment env, venv, with 
     possibly a minimum (typically memory corruption) *)
  let freshen ?min env venv =
    let fresh kind le =
      let l = fresh2 env in
      begin match kind, min with
      | Global, Some ty (* likely unused as global variables are not in venv.vars *)
      | Stack _, Some ty -> VlPairs.add_le ty l; VlPairs.add_le le l
      | _ -> VlPairs.add_le le l
      end; l in
    { venv with vtype = Sv.fold (fun x vtype -> let ty =
          let fresh = fresh x.v_kind in
          match Mv.find x vtype with
          | Direct le -> Direct (fresh le)
          | Indirect(lp, le) -> Indirect(fresh lp, fresh le) in
        Mv.add x ty vtype) venv.vars venv.vtype }

  let ensure_le loc venv1 venv2 =
    let add_le_silent _ oty1 oty2 = add_le_var (oget oty1) (oget oty2); None in
    try ignore (Mv.merge add_le_silent venv1.vtype venv2.vtype)
    with Lvl.Unsat _unsat ->
      Pt.rs_tyerror ~loc
        (Pt.string_error "constraints caused by the loop cannot be satisfied")

  let clone_for_call (env:env) (tyfun:ty_fun) =
    let subst1 = C.clone tyfun.constraints env.constraints in
    let subst (n, s) = (subst1 n, subst1 s) in
    let subst_ty = function
      | IsMsf -> IsMsf
      | IsNormal ty -> let ty =
            match ty with
            | Direct le -> Direct (subst le)
            | Indirect(lp, le) -> Indirect(subst lp, subst le) in
          IsNormal ty in
    List.map subst_ty tyfun.tyout, List.map subst_ty tyfun.tyin,
    subst tyfun.input_corruption, subst tyfun.resulting_corruption

  let corruption env venv ty =
    VlPairs.add_le ty venv.resulting_corruption; (* update corruption level *)
    freshen ?min:(Some ty) env venv

  let corruption_speculative env venv (_, s) = corruption env venv (public env, s)

  let get_resulting_corruption venv = venv.resulting_corruption
  let get_input_corruption venv = venv.input_corruption
end


(* --------------------------------------------------------- *)
let error_unsat loc (_ : Svl.t * Lvl.t list * Lvl.t * Lvl.t) pp e ety ety' =
  Pt.rs_tyerror ~loc
    (Pt.string_error
       "%a has type %a but should be at most %a"
       pp e pp_vty ety pp_vty ety')

let ssafe_test x i =
  let x = L.unloc x in
  match x.v_kind, x.v_ty, i with
  | Reg (_, Direct), _, _ -> true
  | _, Arr (_ (* word size. should be used ? *), len), Pconst v ->
      let v = Conv.int_of_pos (Conv.pos_of_z v) in v < len
  | _ -> false

let content_ty = function
  | Direct le | Indirect (_, le) -> le

(* --------------------------------------------------------- *)
(* Type checking of expressions                              *)

let rec ty_expr env venv loc (e:expr) : vty =
  match e with
  | Pconst _ | Pbool _ | Parr_init _ -> Env.dpublic env

  | Pvar x -> Env.gget venv x

  | Pget (_, _, x, i) ->
      ensure_public_address env venv loc x.gv;
      ensure_public env venv loc i;
      let ty = Env.fresh2 env
      and xty = Env.gget venv x in
      if not (ssafe_test x.gv i) then VlPairs.add_le_speculative (Env.secret env) ty;
      VlPairs.add_le (content_ty xty) ty;
      Direct ty

    (* in the case of sub-arrays, no operation is performed, and there is now
       an alias on the values. Thus the type must be *equal* *)
  | Psub (_, _, _, x, i) ->
      ensure_public env venv loc i;
      Env.gget venv x

  | Pload (_, x, i) ->
      ensure_public env venv loc (Pvar (gkvar x));
      ensure_public env venv loc i;
      Env.dsecret env

  | Papp1(_, e)      -> ty_expr env venv loc e
  | Papp2(_, e1, e2) -> ty_exprs_max env venv loc [e1; e2]
  | PappN(_, es)     -> ty_exprs_max env venv loc es

  | Pif(_, e1, e2, e3) ->
      let ty1 = ty_expr env venv loc e1 in
      let ty2 = ty_expr env venv loc e2 in
      let ty3 = ty_expr env venv loc e3 in
      match ty1 with
      | Indirect _ -> assert false
      | Direct l1 ->
        let do_indirect lp2 le2 lp3 le3 =
          let lp = Env.fresh2 env in
          let le = Env.fresh2 env in
          (* TODO why is condition expression also added to constraints? *)
          VlPairs.add_le l1 lp; VlPairs.add_le lp2 lp; VlPairs.add_le lp3 lp;
          VlPairs.add_le l1 le; VlPairs.add_le le2 le; VlPairs.add_le le3 le;
          Indirect(lp, le) in
        match ty2, ty3 with
        | Direct l2, Direct l3 ->
          let le = Env.fresh2 env in
          VlPairs.add_le l1 le; VlPairs.add_le l2 le; VlPairs.add_le l3 le;
          Direct le
        | Indirect(lp2, le2), Indirect(lp3, le3) ->
          do_indirect lp2 le2 lp3 le3
        | Indirect(lp2, le2), Direct le3 ->
          do_indirect lp2 le2 (Env.public2 env) le3
        | Direct le2, Indirect (lp3, le3) ->
          do_indirect (Env.public2 env) le2 lp3 le3

and ensure_smaller env venv loc e l =
  let ety = ty_expr env venv loc e in
  match ety with
  | Direct le | Indirect (le, _) -> try VlPairs.add_le le l
      with Lvl.Unsat unsat -> error_unsat loc unsat pp_expr e ety (Direct l)

and ensure_public env venv loc e = ensure_smaller env venv loc e (Env.public2 env)

and ensure_public_address env venv loc x = 
  let ety = Env.get_i venv x in
  match ety with
  | Direct _ -> () (* stack or reg arrays have public addresses by definition *)
  | Indirect (le, _) -> try VlPairs.add_le le (Env.public2 env)
      with Lvl.Unsat unsat -> error_unsat loc unsat pp_var_i x ety (Direct (Env.public2 env))

and ty_exprs_max env venv loc es : vty =
  let l = Env.fresh2 env in
  List.iter (fun e -> ensure_smaller env venv loc e l) es;
  Direct l


(* ------------------------------------------------------------- *)
(* MSF status                                                    *)

module MSF : sig

  type t
  val toinit : t
  val exact1 : var_i -> t
  val add : var_i -> t -> t
  val update   : t -> var  -> t

  val enter_if : t -> expr -> t
  val max : t -> t -> t

  val check_msf_trans : t -> var_i -> expr -> unit
  val is_msf_exact    : t -> var_i -> bool
  val check_msf_exact : t -> var_i -> unit
  val loop : Env.env -> L.i_loc -> t -> t
  val end_loop : L.t -> t -> t -> t

  val pp : Format.formatter -> t -> unit

  end = struct

  type t = Sv.t * expr option

  let toinit = (Sv.empty, None)
  let exact xs = (xs, None)
  let trans xs e = (xs, Some e)

  let exact1 x =
    ensure_register ~direct:true x;
    exact (Sv.singleton (L.unloc x))

  let add x (xs, oe) =
    assert (oe = None);
    ensure_register ~direct:true x;
    exact (Sv.add (L.unloc x) xs)

  let update (xs, oe) x =
    match oe with
    | Some e when Sv.mem x (vars_e e) -> toinit
    | _ -> (Sv.remove x xs, oe)

  let enter_if msf e =
    match msf  with
    | (_, Some _) -> toinit
    | (xs, None) -> (xs, Some e)

  let max (xs1, oe1) (xs2, oe2) =
    match oe1, oe2 with
    | None, None -> Sv.inter xs1 xs2, None
    | Some e1, Some e2 when expr_equal e1 e2 -> Sv.inter xs1 xs2, Some e1
    | _, _ -> toinit

  let check_msf_trans (xs, ob) ms b =
    match ob with
    | None -> Pt.rs_tyerror ~loc:(L.loc ms) (Pt.string_error "MSF is not Trans")
    | Some b' ->
      if not (Prog.expr_equal b b') then
        Pt.rs_tyerror ~loc:(L.loc ms)
          (Pt.string_error "the expression %a need to be equal to %a"
             pp_expr b pp_expr  b');
      if not (Sv.mem (L.unloc ms) xs) then
        Pt.rs_tyerror ~loc:(L.loc ms)
          (Pt.string_error "the variable %a is not known to be a msf, only %a are"
             pp_var_i ms pp_vset xs)

  let is_msf_exact (xs, ob) ms =
    match ob with
    | Some _ -> false
    | None -> Sv.mem (L.unloc ms) xs

  let check_msf_exact (xs, ob) ms =
    match ob with
    | Some b ->
      Pt.rs_tyerror ~loc:(L.loc ms) (Pt.string_error "MSF is Trans %a"  pp_expr b)
    | None ->
      if not (Sv.mem (L.unloc ms) xs) then
        Pt.rs_tyerror ~loc:(L.loc ms)
          (Pt.string_error "the variable %a is not known to be a msf, only %a are"
             pp_var_i ms pp_vset xs)

  let pp fmt (xs, oe) =
    match oe with
    | Some e -> Format.fprintf fmt "Trans %a %a" pp_vset xs pp_expr e
    | None   -> Format.fprintf fmt "Exact %a" pp_vset xs

  let loop env loc ((xs, oe) as msf) =
    let xs' = Env.msf_oracle env loc in
    if Sv.subset xs' xs then (xs', oe)
    else
      Pt.rs_tyerror ~loc:(loc.L.base_loc)
        (Pt.string_error "current msf = %a, it should contain %a"
             pp msf pp_vset (Sv.diff xs' xs))

  let end_loop loc ((xsi, oei) as msfi) ((xso, oeo) as msfo)=
    if Sv.subset xsi xso then
      begin match oei, oeo with
      | None, None -> msfi
      | Some ei, Some eo when expr_equal ei eo -> msfi
      | _, _ ->
        if not (Sv.is_empty xsi) then
          Pt.rs_tyerror ~loc
            (Pt.string_error "msf is %a it should be be at least %a"
             pp msfo pp msfi);
        toinit
      end
    else
      Pt.rs_tyerror ~loc
        (Pt.string_error "msf is %a it should be be at least %a"
           pp msfo pp msfi)

end


(* --------------------------------------------------------- *)
(* Type checking of lvalue                                   *)
type msf_e = MSF.t * Env.venv

let ty_lval env ((msf, venv) as msf_e : msf_e) x ety : msf_e =
  (* First path the type ety to make it consistant with the variable info *)
  match x with
  | Lnone _ -> msf_e
  | Lvar x ->
      (* TODO assumption: p = e when p is a pointer and e a direct value means p
         points to a new position, where the expression is *)
      (* as opposed to assigning the pointer directly to the given value *)
      (* likewise, assuming x = p means storing the value pointed by p in x *)
      (* what with p = [ x ]? I believe it does not compile *)
      let lp, le =
        match ety with
        | Direct le -> Env.public2 env, le
        | Indirect(lp, le) -> lp, le in
      let xty = if is_ptr (kind_i x)
          then Indirect(lp, le)
          else Direct le in
      let msf = MSF.update msf (L.unloc x) in
      let venv = Env.set_ty env venv x xty in
      msf, venv

  | Lmem(_, x, i) ->
      ensure_public env venv (L.loc x) (Pvar (gkvar x));
      ensure_public env venv (L.loc x) i;
        (* programmes are assumed to be safe, thus corruption from memory store
           with [x + i] is speculative only *)
      msf, Env.corruption_speculative env venv (content_ty ety)

  | Laset(_, _, x, i) ->
      ensure_public_address env venv (L.loc x) x;
      ensure_public env venv (L.loc x) i;
      let le = content_ty ety in
      if ssafe_test x i then
        let l = Env.fresh2 env in
        let xty =
          match Env.get_i venv x with
          | Direct lx -> VlPairs.add_le lx l; VlPairs.add_le le l; Direct l
          | Indirect (lp, lx) -> VlPairs.add_le lx l; VlPairs.add_le le l;
              Indirect (lp, l)
        in
        msf, Env.set_ty env venv x xty
      else (* mispeculation has necessarily occured *)
        msf, Env.corruption_speculative env venv le

  | Lasub(_, _, _, x, i) ->
      ensure_public_address env venv (L.loc x) x;
      ensure_public env venv (L.loc x) i;
      let le = content_ty ety in
      let l = Env.fresh2 env in
      let xty =
        match Env.get_i venv x with
        | Direct lx -> VlPairs.add_le lx l; VlPairs.add_le le l; Direct l
        | Indirect (lp, lx) -> VlPairs.add_le lx l; VlPairs.add_le le l;
            Indirect (lp, l)
      in
      msf, Env.set_ty env venv x xty

let ty_lvals1 env (msf_e : msf_e) xs ety : msf_e =
  List.fold_left (fun msf_e x -> ty_lval env msf_e x ety) msf_e xs

let ty_lvals env (msf_e : msf_e) xs tys : msf_e =
  List.fold_left2 (ty_lval env) msf_e xs tys


(* -------------------------------------------------------------- *)
(* declassify                                                     *)
(* TODO ensure declassify cannot occur on potentially corrupted   *)
(* stack values                                                   *)

let sdeclassify = "declassify"

let is_declasify annot =
  Pt.Annot.ensure_uniq1 sdeclassify Pt.Annot.none annot <> None

let declassify_lvl env (_, s) = (Env.public env, s)

let declassify env = function
  | Direct le          -> Direct (declassify_lvl env le)
  | Indirect (lp, le)  -> Indirect (lp, declassify_lvl env le)

let declassify_ty env annot ty = if is_declasify annot
  then declassify env ty
  else ty

let declassify_tys env annot tys = if is_declasify annot
  then List.map (declassify env) tys
  else tys


(* --------------------------------------------------------------- *)
(* [ty_instr env msf i] return msf' such that env, msf |- i : msf' *)

let rec ty_instr fenv env ((msf,venv) as msf_e :msf_e) i =
  let loc = i.i_loc.L.base_loc in
  match i.i_desc with
  | Csyscall (xs, _o, es) ->
    (* FIXME make the constraints on es dependant of the syscall _o *)
    List.iter (ensure_public env venv loc) es;
    (* We don't known what happen to MSF after external function call *)
    ty_lvals1 env (MSF.toinit, venv) xs (Env.dsecret env)
  | Cassgn(x, _, _, e) ->
    let ety = ty_expr env venv loc e in
    ty_lval env msf_e x (declassify_ty env i.i_annot ety)

  | Copn(xs, _, o, es) ->
    begin match is_special o, xs, es with
    | Init_msf, [ms], _ ->
      let ms = reg_lval ~direct:true loc ms in
      let venv = Env.set_init_msf env venv ms in
      MSF.exact1 ms, venv

    | Init_msf, _, _ -> assert false

    | Set_msf, [mso], [b; msi] ->
      let mso = reg_lval ~direct:true loc mso and msi = reg_expr ~direct:true loc msi in
      (* do not check b, if check_msf_trans succeed then b is public *)
      MSF.check_msf_trans msf msi b;
      let _, venv = ty_lvals1 env (msf, venv) xs (Env.dpublic env) in
      MSF.exact1 mso, venv

    | Set_msf, _, _ -> assert false

    | Mov_msf, [mso], [msi] ->
      let mso = reg_lval ~direct:true loc mso and msi = reg_expr ~direct:true loc msi in
      MSF.check_msf_exact msf msi;
      MSF.add mso msf, Env.set_ty env venv mso (Env.dpublic env)

    | Mov_msf, _, _ -> assert false

    | Protect, [x], [e; ms] ->
      let _ = reg_lval ~direct:false loc x and _ = reg_expr ~direct:false loc e and
          ms = reg_expr ~direct:true loc ms in
      MSF.check_msf_exact msf ms;
      let xty =
        match ty_expr env venv loc e with
        | Direct (n, _) -> Direct (n, Env.public env)
        | Indirect ((n, _), le) -> Indirect ((n, Env.public env), le) in

      ty_lval env msf_e x xty

    | Protect, _, _ -> assert false

    | Other, _, _  ->
        (* FIXME allows to add more constraints on es depending on the operators, like for div *)
        let ety = ty_exprs_max env venv loc es in
        ty_lvals1 env msf_e xs (declassify_ty env i.i_annot ety)
    end

  | Cif(e, c1, c2) ->
    if is_inline i then
      let msf1, venv1 = ty_cmd fenv env (msf, venv) c1 in
      let msf2, venv2 = ty_cmd fenv env (msf, venv) c2 in
      MSF.max msf1 msf2, Env.max env venv1 venv2
    else begin
      ensure_public env venv loc e;
      let msf1, venv1 = ty_cmd fenv env (MSF.enter_if msf e, venv) c1 in
      let msf2, venv2 = ty_cmd fenv env (MSF.enter_if msf (Papp1(Onot, e)), venv) c2 in
      MSF.max msf1 msf2, Env.max env venv1 venv2
    end

  | Cfor(x, (_, e1, e2), c) ->
      ensure_public env venv loc e1;
      ensure_public env venv loc e2;

      let msf = MSF.loop env i.i_loc msf in
      (* let w, _ = written_vars [i] in *)
      let venv1 = Env.freshen env venv in (* venv <= venv1 *)
      let msf_e = ty_lval env (msf, venv1) (Lvar x) (Env.dpublic env) in
      let (msf', venv') = ty_cmd fenv env msf_e c in
      let msf' = MSF.end_loop loc msf msf' in
      Env.ensure_le loc venv' venv1; (* venv' <= venv1 *)
      msf', venv1

  | Cwhile(_, c1, e, c2) ->
    (* c1; while e do (c2; c1) *)
    (* env, msf <= env1, msf1
       env1, msf1 |- c1 : msf2, env2   env2 |- e : public
       env2, enter_if e msf2 |- c2 : env1, msf1
       --------------------------------------------------------------------------------
       env, msf |- while c1 e c2 : enter_if e msf1
     *)
    ensure_public env venv loc e;
    let msf1 = MSF.loop env i.i_loc msf in
    (* let w, _ = written_vars [i] in *)
    (* NOTE cannot restrict refreshed variables to local modified vars 
       because of memory corruption: if loop body corrupts some stack variable
       constrained to public, the test fails, while marking all stack variables
       as secret is sufficient *)

    let venv1 = Env.freshen env venv in (* venv <= venv1 *)
    let (msf2, venv2) = ty_cmd fenv env (msf1, venv1) c1 in
    let (msf', venv') = ty_cmd fenv env (MSF.enter_if msf2 e, venv2) c2 in
    let msf' = MSF.end_loop loc msf1 msf' in
    Env.ensure_le loc venv' venv1; (* venv' <= venv1 *)
    MSF.enter_if msf' (Papp1(Onot, e)), venv1

  | Ccall (_, xs, f, es) ->
    let fty = FEnv.get_fty fenv f in
    let modmsf = fty.modmsf in
    let tyout, tyin, input_corruption, resulting_corruption = Env.clone_for_call env fty in

    (* corruption so far has effect on callee function *)
    VlPairs.add_le (Env.get_resulting_corruption venv) input_corruption;

    let input_ty e vfty =
      match vfty with
      | IsMsf ->
        (* we don't check that e is public, it is ensured by being msf *)
        let ms = reg_expr ~direct:true loc e in
        MSF.check_msf_exact msf ms
      | IsNormal ety' ->
        let ety = ty_expr env venv loc e in
        try match ety, ety' with
        | Direct le, Direct le' -> VlPairs.add_le le le'
        | Direct le, Indirect (_, le') -> VlPairs.add_le le le'
        | Indirect(lp, le), Direct le' -> VlPairs.add_le lp (Env.public2 env); VlPairs.add_le le le'
        | Indirect(lp, le), Indirect(lp', le') -> VlPairs.add_le lp lp'; VlPairs.add_le le le'
        with Lvl.Unsat unsat -> error_unsat loc unsat pp_expr e ety ety' in
    List.iter2 input_ty es tyin;

    (* callee function has its own effect on this function corruption *)
    let venv = Env.corruption env venv resulting_corruption in

    (* compute the resulting venv *)
    let output_ty msf_e x vfty =
      let ty =
        match vfty with
        | IsMsf -> Env.dpublic env
        | IsNormal ty -> declassify_ty env i.i_annot ty in
      let (msf, venv) = ty_lval env msf_e x ty in
      let msf = if vfty = IsMsf then MSF.add (reg_lval ~direct:true loc x) msf else msf in
      (msf, venv) in
    List.fold_left2 output_ty ((if modmsf then MSF.toinit else msf), venv) xs tyout

and ty_cmd fenv env msf_e c =
  List.fold_left (ty_instr fenv env) msf_e c


(* ------------------------------------------------------------------- *)
(* Do the inference + type checking of function                        *)
(*
#nomodmsf #constraints = "l1 <= transient, l2 <= l1"
   fn f (#public #secret reg u64[1] x, #poly = l1 stack u8 c) ->
        #poly=l1 #poly=l2 u64[1]
*)

let parse_var_annot ~(kind_allowed:bool) ~(msf:bool) (annot: S.annotations) : ulevel list * var_kind =
  let module A = Pt.Annot in
  let kind =
    let check_allowed (id, _) =
      if not kind_allowed then
        Pt.rs_tyerror ~loc:(L.loc id)
          (Pt.string_error "%s not allowed here" (L.unloc id))
      in
    let filters =
      [ sflexible, (fun a -> check_allowed a; A.none a; Flexible);
        sstrict,   (fun a -> check_allowed a; A.none a; Strict)] in
    A.ensure_uniq filters annot in

  let poly arg =
    let error loc =
      Pt.rs_tyerror ~loc
        (Pt.string_error "= ident or = { ident } is expected after “%s”" spoly) in

    let mk_poly loc _nid id =
      if id = stransient || id = spublic || id = ssecret then
        Pt.rs_tyerror ~loc
          (Pt.string_error "%s not allowed as argument of %s" id spoly);
      Poly (L.mk_loc loc id) in

    let on_struct loc _nid (s:S.annotations) =
      List.iter A.none s;
      if List.length s <> 1 then error loc;
      let (s, _) = List.hd s in
      mk_poly (L.loc s) _nid (L.unloc s) in

    let on_id loc _nid id = mk_poly loc _nid id in

    A.on_attribute ~on_id ~on_struct error arg in

  let filters =
    [spublic, (fun a -> A.none a; Public);
     ssecret, (fun a -> A.none a; Secret);
     stransient, (fun a -> A.none a; Transient);
     spoly, poly] in

  let filters =
    if msf then (smsf, (fun a -> A.none a; Msf)) :: filters else filters in

  let lvls = A.process_annot filters annot in

  List.map snd lvls, odfl Flexible kind


(*
  var_kind =
  | Strict
  | Flexible

  ulevel =
  | Poly of string
  | Transient
  | Secret
  | Public
  | Msf

*)

exception Error_after of string * string

let parse_constraints (s:string) : (string * string) list =
  let error expected s n =
    raise (Error_after (expected, String.sub s 0 n)) in

  let is_blank c = c = ' ' || c = '\n' || c = '\t' in

  let rec check_blank expected s first last =
    if first >= last then ()
    else if is_blank s.[first] then
      check_blank expected s (first + 1) last
    else error expected s first in

  let search expected re s n =
    let first =
      try Str.search_forward re s n
      with Not_found -> error expected s n in
    let sub = Str.matched_string s in
    let next = Str.match_end () in
    check_blank expected s n first;
    sub, next in

  let rec skip_blank s n =
    if n < String.length s && is_blank s.[n] then skip_blank s (n+1) else n in

  let ident s n = search "ident" (Str.regexp "[A-Za-z0-9]+") s n in

  let is_le s n = snd (search "<=" (Str.regexp "<=") s n) in

  let is_comma s n = snd (search "," (Str.regexp ",") s n) in

  let parse_c s n =
    let l1, n = ident s n in
    let n = is_le s n in
    let l2, n = ident s n in
    (l1, l2), n in

  let rec parse_rec acc s n =
    let n = skip_blank s n in
    if String.length s <= n then acc
    else
      let n = is_comma s n in
      let c, n = parse_c s n in
      parse_rec (c::acc) s n in

  let n = skip_blank s 0 in
  if String.length s <= n then []
  else
    let c, n = parse_c s n in
    parse_rec [c] s n

let parse_user_constraints (a:Syntax.annotations) : (string * string) list =
  let module A = Pretyping.Annot in
  let sconstraints = "constraints" in
  let on_string loc _ s =
    try parse_constraints s
    with Error_after(kw, s) ->
      Pt.rs_tyerror ~loc
          (Pt.string_error "%s expected after %s" kw s) in
  let error loc =
    Pt.rs_tyerror ~loc
          (Pt.string_error "attribute for %s should be a string" sconstraints) in

   List.flatten
     (List.map snd (A.process_annot [sconstraints, A.on_attribute ~on_string error] a))

let init_constraint fenv f =
  let env = Env.init () in
  let venv = Env.empty env in
  let tbl = Hashtbl.create 97 in
  Hashtbl.add tbl spublic    (Env.public2 env);
  Hashtbl.add tbl ssecret    (Env.secret2 env);
  (* export function: all input type should be at most transient and msf is not allowed *)
  (* the new version does not take that into accout, does it? *)
  let export = f.f_cc = Export in

  let add_lvl s =
    let s = L.unloc s in
    try Hashtbl.find tbl s
    with Not_found ->
      let l = Env.fresh2 ~name:s env in
      Hashtbl.add tbl s l;
      l in

  let to_lvl = function
    | Poly s -> add_lvl s
    | Secret -> Env.secret2 env
    | Transient -> (Env.public env, Env.secret env)
    | Public | Msf -> Env.public2 env in

  let error_msf loc =
    Pt.rs_tyerror ~loc
      (Pt.string_error "%s annotation not allowed here" smsf) in

  let mk_vty loc ~(msf:bool) x ls =
    let msf, ovty =
      match ls with
      | [] -> None, None
      | [l] ->
        if not msf && l = Msf then error_msf loc;
        Some (l = Msf), Some(Direct (to_lvl l))
      | [l1; l2] ->
        if (l1 = Msf || l2 = Msf) then error_msf loc;
        Some false, Some(Indirect (to_lvl l1, to_lvl l2))
      | _ ->
        Pt.rs_tyerror ~loc:(x.v_dloc)
          (Pt.string_error "invalid security annotations %a" pp_var x) in
    let vty =
      match ovty with
      | None ->
        begin match x.v_kind with
        | Const -> Env.dpublic env
        | Stack Direct -> Direct (Env.fresh2 env)
        | Stack (Pointer _) -> Indirect(Env.fresh2 env, Env.fresh2 env)
        | Reg (_, Direct) -> Direct (Env.fresh2 env)
        | Reg (_, Pointer _) -> Indirect(Env.fresh2 env, Env.fresh2 env)
        | Inline -> Env.dpublic env
        | Global -> Env.dpublic env (* unsure *)
        end
      | Some ty -> (* this partly has the same role as Env.init_ty. Remove one occurence? *)
        begin match x.v_kind, ty with
        | Const, Direct _ -> ()
        | Stack Direct, Direct _ -> ()
        | Stack (Pointer _), Indirect _ -> ()
        | Reg (_, Direct), Direct _ -> ()
        | Reg (_, Pointer _), Indirect _ -> ()
        | Inline, Direct _ -> ()
        | Global, Direct _ -> ()
        | _ ->
          Pt.rs_tyerror ~loc
            (Pt.string_error "invalid security annotations for %a" pp_var x)
        end; ty in
    msf, vty in

  let process_return x annot =
    let loc = L.loc x and x = L.unloc x in
    let ls, _ = parse_var_annot ~kind_allowed:false ~msf:(not export) annot in
    mk_vty loc ~msf:(not export) x ls in

  (* process function outputs *)
  let tyout = List.map2 process_return f.f_ret f.f_outannot in

  (* infer msf_oracle info *)
  let msfs =
    infer_msf_c fenv (Env.get_msf_oracle env) f.f_body
      (List.fold_left2 (fun s x (msf, _) ->
           if odfl false msf then Sv.add (L.unloc x) s else s)
         Sv.empty f.f_ret tyout) in

  if export && not (Sv.is_empty msfs) then
    Pt.rs_tyerror ~loc:f.f_loc
      (Pt.string_error
         "%a need to be a msf, this is not allowed in export function" pp_vset msfs);

  (* process function inputs *)
  let process_param venv x =
    let ls, vk = parse_var_annot ~kind_allowed:true ~msf:(not export) x.v_annot in
    let msf, vty = mk_vty x.v_dloc ~msf:(not export) x ls in
    let msf =
      match msf with
      | None -> Sv.mem x msfs
      | Some b ->
        if b <> Sv.mem x msfs then
          Pt.rs_tyerror ~loc:x.v_dloc
            (Pt.string_error "%a %sneed to be a msf" pp_var x (if b then "do not " else ""));
        b in
    if export then
      begin match vty with
      | Direct l ->
        begin
          try VlPairs.add_le (Env.public env, Env.secret env) l
          with Lvl.Unsat _unsat ->
            Pt.rs_tyerror ~loc:(x.v_dloc)
              (Pt.string_error "security annotation for %a should be at least %s"
                 pp_var x stransient)
        end

      | _ -> assert false
      end;
    let venv = Env.add_var env venv x vk vty in
    let ty = if msf then IsMsf else IsNormal vty in
    venv, ty in

  let venv, tyin = List.map_fold process_param venv f.f_args in

  (* build the constraints *)
  let do_constraint (s1, s2) =
    let get s =
      try Hashtbl.find tbl s
      with Not_found ->
        Pt.rs_tyerror ~loc:f.f_loc (Pt.string_error "unbound security level %s" s) in
    try VlPairs.add_le (get s1) (get s2)
    with Lvl.Unsat _unsat ->
      Pt.rs_tyerror ~loc:f.f_loc
        (Pt.string_error "cannot add constraint %s <= %s, it is inconsistant" s1 s2) in
  List.iter do_constraint (parse_user_constraints f.f_user_annot);

  (* init type for local *)
  let do_local venv x =
    let ls, vk = parse_var_annot ~kind_allowed:true ~msf:false x.v_annot in
    let _, vty = mk_vty x.v_dloc ~msf:false x ls in
    Env.add_var env venv x vk vty in

  let venv = List.fold_left do_local venv (Sv.elements (locals f)) in

  (* infer modmsf and check consistency with user info *)
  let modmsf = modmsf_c fenv f.f_body in
  let umodmsf =
    Pretyping.Annot.ensure_uniq
       ["modmsf", (fun a -> Pt.Annot.none a; true);
        "nomodmsf", (fun a -> Pt.Annot.none a; false)] f.f_user_annot in
  begin match umodmsf with
  | None -> ()
  | Some umodmsf ->
    if umodmsf <> modmsf then
      Pt.rs_tyerror ~loc:f.f_loc
        (Pt.string_error "annotation %a should be %a" pp_modmsf umodmsf pp_modmsf modmsf)
  end;

  env, venv, tyin, tyout, modmsf


let rec ty_fun fenv fn =
  try Hf.find fenv.env_ty fn
  with Not_found ->
    let fty = ty_fun_infer fenv fn in
    Hf.add fenv.env_ty fn fty;
    fty

and ty_fun_infer fenv fn =
  let f = FEnv.get_fun_def fenv fn in
  (* First compute all function call by f and recurse *)
  let _, called = written_vars_fc f in
  Mf.iter (fun fn _ -> ignore (ty_fun fenv fn)) called;
  let env, venv, tyin, tyout, modmsf = init_constraint fenv f in
  (* init msf status *)
  let msf =
    List.fold_left2 (fun msf x ty ->
        if ty = IsMsf then MSF.add (L.mk_loc x.v_dloc x) msf else msf)
      MSF.toinit f.f_args tyin in
  (* start type checking of the body *)
  let msf, venv = ty_cmd fenv env (msf, venv) f.f_body in
  (* build the resulting type *)
  let doout x (omsf, ty) =
    let le_ty ty1 ty2 =
      try
        match ty1, ty2 with
        | Direct le1, Direct le2 -> VlPairs.add_le le1 le2
        | Indirect(lp1, le1), Indirect(lp2, le2) ->
          VlPairs.add_le lp1 lp2; VlPairs.add_le le1 le2
        | _, _ -> assert false
      with Lvl.Unsat _unsat ->
        Pt.rs_tyerror ~loc:(L.loc x)
          (Pt.string_error "return type for %a is %a it should be less than %a"
             pp_var_i x pp_vty ty1 pp_vty ty2) in
    match omsf with
    | Some true  -> MSF.check_msf_exact msf x; IsMsf
    | Some false ->
      if MSF.is_msf_exact msf x then
        Pt.rs_tyerror ~loc:(L.loc x)
          (Pt.string_error "return annotation for %a should be %s" pp_var_i x smsf);
      le_ty (Env.get_i venv x) ty;
      IsNormal ty
    | None ->
      if MSF.is_msf_exact msf x then IsMsf
      else (le_ty (Env.get_i venv x) ty; IsNormal ty) in

  let tyout = List.map2 doout f.f_ret tyout in
  let resulting_corruption = Env.get_resulting_corruption venv in
  let input_corruption = Env.get_input_corruption venv in
  let (n1, s1), (n2, s2) = resulting_corruption, input_corruption in

  let constraints = Env.constraints env in
  let add ls vty =
    match vty with
    | IsMsf -> ls
    | IsNormal (Direct (n, s)) -> n :: s :: ls
    | IsNormal (Indirect ((np, sp), (ne, se))) -> np :: sp :: ne :: se :: ls in
  let to_keep = List.fold_left add (List.fold_left add [n1; s1; n2; s2] tyin) tyout in

  C.prune constraints to_keep;
  let fty = { modmsf; tyin; tyout; constraints; resulting_corruption; input_corruption } in
  Format.eprintf "%a@." pp_funty (f.f_name.fn_name, fty);
  let tomax = List.fold_left add [n2; s2] tyin in
  let tomin = List.fold_left add [n1; s1] tyout in
  C.optimize constraints ~tomin ~tomax;
  Format.eprintf "after optimization:@.%a@." pp_funty (f.f_name.fn_name, fty);
  fty


let ty_prog (prog:'info prog) fl =
  let prog = snd prog in
  let fenv = { env_ty = Hf.create 101; env_def = prog } in
  let fl =
    if fl = [] then
      List.rev_map (fun f -> f.f_name) prog
    else
      let get fn =
        try (List.find (fun f -> f.f_name.fn_name = fn) prog).f_name
        with Not_found ->
          hierror ~loc:Lnone ~kind:"speculative constant type checker" "unknown function %s" fn in
      List.map get fl in
  List.iter (fun fn -> ignore (ty_fun fenv fn)) fl
