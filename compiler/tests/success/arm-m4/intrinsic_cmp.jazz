export
fn cmp(reg u32 arg0, reg u32 arg1) -> reg u32 {
    reg bool n, z, c, v;

    n, z, c, v = #CMP(arg0, arg1);

    // Immediates.
    n, z, c, v = #CMP(arg0, 3);

    // Conditions.
    n, z, c, v = #CMPcc(arg0, arg1, z, n, z, c, v);            // EQ
    n, z, c, v = #CMPcc(arg0, arg1, !z, n, z, c, v);           // NE
    n, z, c, v = #CMPcc(arg0, arg1, c, n, z, c, v);            // CS
    n, z, c, v = #CMPcc(arg0, arg1, !c, n, z, c, v);           // CC
    n, z, c, v = #CMPcc(arg0, arg1, n, n, z, c, v);            // MI
    n, z, c, v = #CMPcc(arg0, arg1, !n, n, z, c, v);           // PL
    n, z, c, v = #CMPcc(arg0, arg1, v, n, z, c, v);            // VS
    n, z, c, v = #CMPcc(arg0, arg1, !v, n, z, c, v);           // VC
    n, z, c, v = #CMPcc(arg0, arg1, c && !z, n, z, c, v);      // HI
    n, z, c, v = #CMPcc(arg0, arg1, !c || z, n, z, c, v);      // LS
    n, z, c, v = #CMPcc(arg0, arg1, n == v, n, z, c, v);       // GE
    n, z, c, v = #CMPcc(arg0, arg1, n != v, n, z, c, v);       // LT
    n, z, c, v = #CMPcc(arg0, arg1, !z && n == v, n, z, c, v); // GT
    n, z, c, v = #CMPcc(arg0, arg1, z || n != v, n, z, c, v);  // LE

    n, z, c, v = #CMPcc(arg0, 3, z, n, z, c, v);

    return arg0;
}
