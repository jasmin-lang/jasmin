param int CHACHA_ROUNDS=20;

// nonce : 8 bytes
// key : 32 bytes
// counter : 8 bytes (starts at 0)
inline fn __init_ref1( reg u64 nonce key, #msf reg u64 ms) ->   stack u32[16], #msf reg u64
{
   inline int i, j;
   stack u32[16] st;
   reg u32 t;

  st[0] = 0x61707865;
  st[1] = 0x3320646e;
  st[2] = 0x79622d32;
  st[3] = 0x6b206574;

  // reads 8 u32 from pointer key
  for i=0 to 8
  {
    t = (u32)[key + 4*i];
    st[4+i] = t;
  }

  // 64-bit counter (same as st[12] = 0; st[13] = 0;)
  st[u64 6] = 0;

  // reads 2 u32 from pointer nonce
  for i=0 to 2
  { t = (u32)[nonce + 4*i];
    st[14+i] = t; }

  return st, ms;
}


// increments 64-bit counter
inline fn __increment_counter_ref1( stack u32[16] st, #msf reg u64 ms) ->  stack u32[16], #msf reg u64
{
  reg u64 t;

  t = st[u64 6];
  t += 1;
  st[u64 6] = t;

  return st, ms;
}


///////////////////////////////////////////////////////////////////////////////
// store 'xor' ////////////////////////////////////////////////////////////////

inline fn __update_ptr_xor_ref1( reg u64 output plain len,  inline int n, #msf reg u64 ms) ->  reg u64,  reg u64,  reg u64, #msf reg u64
{
  output += n;
  plain += n;
  len -= n;
  return output, plain, len, ms;
}


inline fn __sum_states_store_xor_ref1(
   stack u64 s_output s_plain s_len,
   reg u32[16] k,  stack u32 k14 k15,
   stack u32[16] st,
  #msf reg u64 ms
) ->  stack u64,  stack u64,  stack u64, #msf reg u64
{
   inline int i;
   reg u64[8] kk;
   reg u64 output plain len;
   reg u64 aux;
   reg u64 trans;
   inline bool b;
   reg u64 temp;

  // store                        // sum states
  // i = 0 : 1 dead
                                  k[1] += st[1];
                                  k[0] += st[0];
  kk[0] = (64u) k[1];
  kk[0] <<= 32;
  aux = (64u)k[0];
  kk[0] ^= aux;

  //plain = s_plain;
  trans = s_plain;
  plain = #protect(trans, ms);
  kk[0] ^= (u64)[plain + 8*0];

  // i = 1 : 2 dead
                                  k[3] += st[3];
                                  k[2] += st[2];
  kk[1] = (64u) k[3];
  kk[1] <<= 32;
  aux = (64u)k[2];
  kk[1] ^= aux;
  kk[1] ^= (u64)[plain + 8*1];

  // output = s_output;
  trans = s_output;
  output = #protect(trans, ms);
  (u64)[output + 8*0] = kk[0];

  for i=2 to 8
  {
    //b = 2*i+1 == 15;
    temp = 2 * i;
    temp += 1;
    b = temp == 15;
    k[2*i+1] = k15 if b;

    b = 2*i == 14;
    k[2*i] = k14 if b;

    k[2*i+1] += st[2*i+1];
    k[2*i] += st[2*i];
    kk[i] = (64u)(k[2*i+1]);
    kk[i] <<= 32;
    aux = (64u)k[2*i];
    kk[i] ^= aux;
    kk[i] ^= (u64)[plain + 8*i];
    (u64)[output + 8*(i-1)] = kk[i-1];
  }

  (u64)[output + 8*7] = kk[7];

  // len = s_len;
  trans = s_len;
  len = #protect(trans, ms);

  output, plain, len, ms = __update_ptr_xor_ref1(output, plain, len, 64, ms);

  s_output = output;
  s_plain = plain;
  s_len = len;

  return s_output, s_plain, s_len, ms;
}


inline fn __store_xor_last_ref1( stack u64 s_output s_plain s_len,  reg u32[16] k,  stack u32 k14 k15, #msf reg u64 ms)
{
   inline int i;
   reg u64 j output plain len len8;
   reg u64 t;
  reg u32 u;
  stack u32[16] s_k;
  reg u8 pi;
   reg u64 trans;

  // copy k to stack
  for i=0 to 14
  { s_k[i] = k[i]; }

  u = k14;
  s_k[14] = u;

  u = k15;
  s_k[15] = u;

  //output = s_output;
  trans = s_output;
  output = #protect(output, ms);

  //plain = s_plain;
  trans = s_plain;
  plain = #protect(trans, ms);

  //len = s_len;
  trans = s_len;
  len = #protect(trans, ms);

  // u64 at a time
  len8 = len;
  len8 >>= 3;
  j = 0;
  while(j < len8)
  {
    t = (u64)[plain + 8*j];
    t ^= s_k[u64 (int)j];
    (u64)[output + 8*j] = t;
    j += 1;
  }
  j <<= 3;

  // u8 at a time
  while(j < len)
  {
    pi = (u8)[plain + j];
    pi ^= s_k[u8 (int)j];
    (u8)[output + j] = pi;
    j += 1;
  }
}


// the following implementation requires:
// - (even) param int CHACHA_ROUNDS;
// - inline fn __init_ref1(reg u64 nonce key) -> stack u32[16] (check chacha_state.jinc)
// - inline fn __increment_counter_ref1(stack u32[16] state) -> stack u32[16] (check chacha_state.jinc)

// used;
inline fn __copy_state_ref1( stack u32[16] st, #msf reg u64 ms) ->  reg u32[16],  stack u32,  stack u32, #msf reg u64
{
   inline int i;
   reg u32 k14 k15;
   reg u32[16] k;
   stack u32 s_k14 s_k15;

  k14 = st[14];
  s_k14 = k14;

  k15 = st[15];
  s_k15 = k15;

  for i=0 to 14
  { k[i] = st[i]; }

  return k, s_k14, s_k15, ms;
}


// used; performs two quarter rounds, inlined 'line's;
inline fn __half_round_inline_ref1(
   reg u32[16] k,
   inline int a0 b0 c0 d0
             a1 b1 c1 d1,
  #msf reg u64 ms
) -> reg u32[16], #msf reg u64
{

  //k = line(k, a, b, d, 16);
  k[a0] += k[b0];
  k[a1] += k[b1];

  k[d0] ^= k[a0];
  k[d1] ^= k[a1];

  _, _, k[d0] = #ROL_32(k[d0], 16);
  _, _, k[d1] = #ROL_32(k[d1], 16);

  //k = line(k, c, d, b, 12);
  k[c0] += k[d0];
  k[c1] += k[d1];

  k[b0] ^= k[c0];
  k[b1] ^= k[c1];

  _, _, k[b0] = #ROL_32(k[b0], 12);
  _, _, k[b1] = #ROL_32(k[b1], 12);

  //k = line(k, a, b, d, 8);
  k[a0] += k[b0];
  k[a1] += k[b1];

  k[d0] ^= k[a0];
  k[d1] ^= k[a1];

  _, _, k[d0] = #ROL_32(k[d0], 8);
  _, _, k[d1] = #ROL_32(k[d1], 8);

  //k = line(k, c, d, b, 7);
  k[c0] += k[d0];
  k[c1] += k[d1];

  k[b0] ^= k[c0];
  k[b1] ^= k[c1];

  _, _, k[b0] = #ROL_32(k[b0], 7);
  _, _, k[b1] = #ROL_32(k[b1], 7);

  return k, ms;
}


// used;
inline fn __double_round_inline_ref1( reg u32[16] k,  stack u32 k1 k2 k14 k15, #msf reg u64 ms) ->  reg u32[16],  stack u32,  stack u32,  stack u32,  stack u32, #msf reg u64
{
  k[2] = k2; k[14] = k14;

  k, ms = __half_round_inline_ref1(k, 0, 4, 8,  12,
                                  2, 6, 10, 14, ms);
  k2 = k[2]; k14 = k[14];
  k[1] = k1; k[15] = k15;

  k, ms = __half_round_inline_ref1(k, 1, 5, 9,  13,
                                  3, 7, 11, 15, ms);

  k, ms = __half_round_inline_ref1(k, 1, 6, 11, 12,
                                  0, 5, 10, 15, ms);

  k1 = k[1]; k15 = k[15];
  k[2] = k2; k[14] = k14;

  k, ms = __half_round_inline_ref1(k, 2, 7, 8, 13,
                                  3, 4, 9, 14, ms);

  k2 = k[2]; k14 = k[14];

  return k, k1, k2, k14, k15, ms;
}


// used;
inline fn __rounds_inline_ref1( reg u32[16] k,  stack u32 k14 k15, #msf reg u64 ms) ->  reg u32[16],  stack u32,  stack u32, #msf reg u64
{
  stack u32 k1 k2;
   stack u32 s_c;
   reg u32 c;
   reg u32 trans;
   inline bool b;

  k1 = k[1];
  k2 = k[2];

  c = (CHACHA_ROUNDS/2);

  while
  {
    s_c = c;

    k, k1, k2, k14, k15, ms = __double_round_inline_ref1(k, k1, k2, k14, k15, ms);

    //c = s_c;
    trans = s_c;
    c = #protect_32(trans, ms);
    (_,_,_,_,c) = #DEC_32(c);
    b = c > 0;
  } (b) {
    ms = #set_msf(b, ms);
  }
  ms = #set_msf(!b, ms);

  k[1] = k1;
  k[2] = k2;

  return k, k14, k15, ms;
}


// used;
inline fn __sum_states_ref1( reg u32[16] k,  stack u32 k14 k15,  stack u32[16] st, #msf reg u64 ms) ->  reg u32[16],  stack u32,  stack u32, #msf reg u64
{
  inline int i;
  stack u32 k13;
  reg u32 t;

  for i=0 to 14
  { k[i] += st[i]; }
  k13 = k[13];

  t = k14;
  t += st[14];
  k14 = t;

  t = k15;
  t += st[15];
  k15 = t;

  k[13] = k13;

  return k, k14, k15, ms;
}


export fn chacha_xor_ref1( #transient reg u64 output plain len nonce key)
{
   stack u64 s_output s_plain s_len;
  stack u32[16] st;
  reg u32[16] k;  // the full state is in k[0..14] and k15;
  stack u32 k14 k15;
  #msf reg u64 ms;
   inline bool b;
   reg u64 trans;
   inline int i;

  s_output = output;
  s_plain = plain;
  s_len = len;

  ms = #init_msf();
  st, ms = __init_ref1(nonce, key, ms);

  while {
    //len = s_len;
    trans = s_len;
    len = #protect(trans, ms);
    b = len >= 64;
  } (b)
  {
    ms = #set_msf(b, ms);
    k, k14, k15, ms = __copy_state_ref1(st, ms);
    k, k14, k15, ms = __rounds_inline_ref1(k, k14, k15, ms);
    s_output, s_plain, s_len, ms = __sum_states_store_xor_ref1(s_output, s_plain, s_len, k, k14, k15, st, ms);
    st, ms = __increment_counter_ref1(st, ms);
  }
  ms = #set_msf(!b, ms);

  b = len > 0;
  if(b)
  {
    ms = #set_msf(b, ms);
    k, k14, k15, ms = __copy_state_ref1(st, ms);
    k, k14, k15, ms = __rounds_inline_ref1(k, k14, k15, ms);
    k, k14, k15, ms = __sum_states_ref1(k, k14, k15, st, ms);
    __store_xor_last_ref1(s_output, s_plain, s_len, k, k14, k15, ms);
  }

  ms = #init_msf();
}
