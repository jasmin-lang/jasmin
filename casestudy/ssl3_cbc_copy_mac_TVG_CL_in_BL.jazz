inline
fn lzcnt(reg u64 x) -> reg bool, reg u64 {
  reg u64 result;
  reg bool zf;
  _, _, _, _, zf, result = #LZCNT(x);
  return zf, result;
}

inline fn mod_TV(reg u64 a, reg u64 b) -> reg u64 {
  reg u64 flag one zero dividend modulo result;
  reg u64 lzb lzb_m1 b_lzb b_lzb_m1 temp2;
  reg bool lzaz lzbz cf;

  flag = 0x1234;
  one = 1;
  zero = 0;

  lzbz, lzb = lzcnt(b);
  flag = zero if lzbz;
  lzaz, _ = lzcnt(a);
  flag = one if lzaz;

  lzb_m1 = #LEA(lzb - 1);
  b_lzb_m1 = b;
  b_lzb_m1 = b_lzb_m1 << lzb_m1;
  dividend = #LEA(b_lzb_m1 + a);

  b_lzb = b_lzb_m1 << 1;
  cf, temp2 = b_lzb + a;
  dividend = temp2 if !cf;

  dividend = a if flag == 1;
  temp2 = 0xFFFFFFFFFFFFFFFF;
  dividend = temp2 if flag == 0;  // lzb = 0 and lza ≠ 0,
                              // to leak big number if overflow happens
  modulo = dividend % b;
  result = modulo;
  result = a if flag == 0;    // lzb = 0 and lza ≠ 0
  return result;
}

fn rotate_offset_TVG(reg u32 md_size mac_start scan_start) -> reg u32 {
  reg u32 numerator, rotate_offset;
  reg u64  ro;
  numerator = mac_start;
  numerator -= scan_start;
  ro = mod_TV((64u)numerator, (64u)md_size);
  rotate_offset = (32u) ro;
  return rotate_offset;
}

inline fn rotate_mac_CL(reg u32 md_size rotate_offset, reg u64 out rotated_mac) {
  reg u8 new;
  reg u64 i, zero, ro;

  zero = 0;
  ro = (64u) rotate_offset;
  i = 0;
  while (i < md_size) {
    new = (u8)[rotated_mac + ro];
    (u8)[out + i] = new;
    ro += 1;
    ro = zero if md_size <= ro;
    i += 1;
  }
}

inline fn init_scan_start(reg u64 rec, reg u32 orig_len, reg u32 md_size) -> reg u64, reg u32, reg u32, reg u32 {
  reg u32 mac_start, mac_end, scan_start, temp;
  reg u64 zero, data;
  zero = 0;
  data = (u64)[rec + 16];
  mac_end = (u32)[rec + 4];
  mac_start = mac_end;
  mac_start -= md_size;
  scan_start = 0;
  temp = md_size;
  temp += 256;
  if (orig_len > temp) {
    scan_start = orig_len;
    scan_start -= temp;
  }
  return data, scan_start, mac_start, mac_end;
}

inline fn init_rotated_mac_mem(reg u64 rotated_mac, reg u64 data, reg u32 scan_start, reg u32 mac_start, reg u32 mac_end, reg u32 orig_len, reg u32 md_size) {
  reg u32 old, new;
  reg u64 i, j, zero;

  i = 0;
  while (i < 64) {
    (u8)[rotated_mac + i] = 0;
    i += 1;
  }

  zero = 0;
  i = (64u) scan_start;
  j = 0;
  while(i < orig_len) {
    new = (32u)(u8)[data + (int)i];
    old = (32u)(u8)[rotated_mac + j];
    new = old if i < mac_start;
    new = old if i >= mac_end;
    (u8)[rotated_mac + j] = new;
    j += 1;
    j = zero if md_size <= j;
    i += 1;
  }
}

export
fn
ssl3_cbc_copy_mac_TVG_CL(
    reg u64 out,
    reg u64 rec,
    reg u32 orig_len,
    reg u32 md_size,
    reg u64 rotated_mac
  )
{
  // assuming CBC_MAC_ROTATE_IN_PLACE is not defined
  reg u32 mac_start, mac_end, scan_start;
  reg u64 i, j, zero, data;
  reg u32 rotate_offset, old, new, temp;

  data, scan_start, mac_start, mac_end = init_scan_start(rec, orig_len, md_size);
  init_rotated_mac_mem(rotated_mac, data, scan_start, mac_start, mac_end, orig_len, md_size);
  rotate_offset = rotate_offset_TVG(md_size, mac_start, scan_start);
  rotate_mac_CL(md_size, rotate_offset, out, rotated_mac);
}

inline
fn test_with_secret_TVG_CL(reg u32 secret_mac_end) {
  reg u64 rec, out, data, rotated_mac;
  reg u32 result;
  inline int i;

  rec = 0x2000;
  out = 0x3000;
  data = 0x4000;
  rotated_mac = 0x500;
  (u64)[rec + 16] = data;
  (u32)[rec + 4] = secret_mac_end;
  for i = 0 to 0x200 {
    (u8)[data + i] = 0;
  }

  ssl3_cbc_copy_mac_TVG_CL(
    out,
    rec,
    0x200,
    64,
    rotated_mac
  );
}

inline fn test_TVG_CL_XX() {test_with_secret_TVG_CL(326);}
inline fn test_TVG_CL_YY() {test_with_secret_TVG_CL(448);}

exec test_TVG_CL_XX test_TVG_CL_YY (0x4000 : 0x200, 0x3000 : 64, 0x2000 : 100, 0x500: 64)